// Code generated by error-binding-generator. DO NOT EDIT.

package evmerrors

import (
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
)

// DecoderFunc is a function that decodes error parameters from hex data
type DecoderFunc func(data []byte) (ContractError, error)

// ErrorDecoders maps error selectors to their decoder functions
var ErrorDecoders = map[string]DecoderFunc{
	"0x8b82bf2b": decodeCDNPaymentAlreadyTerminated, // CDNPaymentAlreadyTerminated(uint256)
	"0x34fee1da": decodeCacheMissPaymentAlreadyTerminated, // CacheMissPaymentAlreadyTerminated(uint256)
	"0x1176a89f": decodeCallerNotPayer, // CallerNotPayer(uint256,address,address)
	"0x7e47554b": decodeCallerNotPayerOrPayee, // CallerNotPayerOrPayee(uint256,address,address,address)
	"0xed73634e": decodeCallerNotPayments, // CallerNotPayments(address,address)
	"0x323d3c67": decodeCannotModifyTerminatedRailBeyondEndEpoch, // CannotModifyTerminatedRailBeyondEndEpoch(uint256,uint256,uint256)
	"0x1d932033": decodeCannotSettleFutureEpochs, // CannotSettleFutureEpochs(uint256,uint256,uint256)
	"0x20827009": decodeCannotSettleTerminatedRailBeforeMaxEpoch, // CannotSettleTerminatedRailBeforeMaxEpoch(uint256,uint256,uint256)
	"0xc41d66e8": decodeChallengeWindowTooEarly, // ChallengeWindowTooEarly(uint256,uint256,uint256)
	"0x45d4d477": decodeCommissionExceedsMaximum, // CommissionExceedsMaximum(uint8,uint256,uint256)
	"0x49c4e4f0": decodeCommissionRateTooHigh, // CommissionRateTooHigh(uint256,uint256)
	"0x92dfe5fc": decodeCurrentLockupLessThanOldLockup, // CurrentLockupLessThanOldLockup(address,address,uint256,uint256)
	"0x1f7a6b73": decodeDataSetNotFoundForRail, // DataSetNotFoundForRail(uint256)
	"0x8a961ba3": decodeDataSetNotRegistered, // DataSetNotRegistered(uint256)
	"0x211a40c0": decodeDataSetPaymentAlreadyTerminated, // DataSetPaymentAlreadyTerminated(uint256)
	"0xd7c45de5": decodeDataSetPaymentBeyondEndEpoch, // DataSetPaymentBeyondEndEpoch(uint256,uint256,uint256)
	"0x23d359a3": decodeDivisionByZero, // DivisionByZero()
	"0xca210722": decodeDuplicateMetadataKey, // DuplicateMetadataKey(uint256,string)
	"0x6a514229": decodeExtraDataRequired, // ExtraDataRequired()
	"0xfadd7dd5": decodeFeeWithdrawalNativeTransferFailed, // FeeWithdrawalNativeTransferFailed(address,uint256)
	"0x54f754fd": decodeFilBeamServiceNotConfigured, // FilBeamServiceNotConfigured(uint256)
	"0x6fb42560": decodeInsufficientCurrentLockup, // InsufficientCurrentLockup(address,address,uint256,uint256)
	"0xcdc76e7c": decodeInsufficientFundsForOneTimePayment, // InsufficientFundsForOneTimePayment(address,address,uint256,uint256)
	"0x707dfeab": decodeInsufficientFundsForSettlement, // InsufficientFundsForSettlement(address,address,uint256,uint256)
	"0x18d8ed64": decodeInsufficientLockupForSettlement, // InsufficientLockupForSettlement(address,address,uint256,uint256)
	"0x3e2f02c1": decodeInsufficientNativeTokenForBurn, // InsufficientNativeTokenForBurn(uint256,uint256)
	"0xe610210c": decodeInsufficientUnlockedFunds, // InsufficientUnlockedFunds(uint256,uint256)
	"0x985bf88a": decodeInvalidChallengeCount, // InvalidChallengeCount(uint256,uint256,uint256)
	"0x25a0c7f7": decodeInvalidChallengeEpoch, // InvalidChallengeEpoch(uint256,uint256,uint256,uint256)
	"0x5d0ad0ad": decodeInvalidChallengeWindowSize, // InvalidChallengeWindowSize(uint256,uint256)
	"0xcba16d8c": decodeInvalidDataSetId, // InvalidDataSetId(uint256)
	"0xbb4e0af7": decodeInvalidEpochRange, // InvalidEpochRange(uint256,uint256)
	"0x2e78e91f": decodeInvalidRateChangeQueueState, // InvalidRateChangeQueueState(uint256,uint256)
	"0x42d750dc": decodeInvalidSignature, // InvalidSignature(address,address)
	"0xd615d706": decodeInvalidSignatureLength, // InvalidSignatureLength(uint256,uint256)
	"0xf72a2118": decodeInvalidTerminatedRailModification, // InvalidTerminatedRailModification(uint256,uint256,uint256,uint256)
	"0x2c5e9e88": decodeInvalidTopUpAmount, // InvalidTopUpAmount(uint256)
	"0x3bea1fb8": decodeLockupExceedsFundsInvariant, // LockupExceedsFundsInvariant(address,address,uint256,uint256)
	"0x249e1b0e": decodeLockupFixedIncreaseNotAllowedDueToInsufficientFunds, // LockupFixedIncreaseNotAllowedDueToInsufficientFunds(address,address,uint256,uint256)
	"0xdb3137ef": decodeLockupInconsistencyDuringRailFinalization, // LockupInconsistencyDuringRailFinalization(uint256,address,address,uint256,uint256)
	"0x020c2e30": decodeLockupNotSettledRateChangeNotAllowed, // LockupNotSettledRateChangeNotAllowed(uint256,address,bool,uint256,uint256)
	"0x9bd4f7f6": decodeLockupPeriodChangeNotAllowedDueToInsufficientFunds, // LockupPeriodChangeNotAllowedDueToInsufficientFunds(address,address,uint256,uint256)
	"0xb8afa055": decodeLockupPeriodExceedsOperatorMaximum, // LockupPeriodExceedsOperatorMaximum(address,address,uint256,uint256)
	"0xa18ff4af": decodeLockupRateInconsistent, // LockupRateInconsistent(uint256,address,uint256,uint256)
	"0xd909f4e2": decodeLockupRateLessThanOldRate, // LockupRateLessThanOldRate(uint256,address,uint256,uint256)
	"0xab9ff1e7": decodeMaxProvingPeriodZero, // MaxProvingPeriodZero()
	"0x9b7cf882": decodeMetadataArrayCountMismatch, // MetadataArrayCountMismatch(uint256,uint256)
	"0xa3741480": decodeMetadataKeyAndValueLengthMismatch, // MetadataKeyAndValueLengthMismatch(uint256,uint256)
	"0xd307879f": decodeMetadataKeyExceedsMaxLength, // MetadataKeyExceedsMaxLength(uint256,uint256,uint256)
	"0x9a16e82a": decodeMetadataValueExceedsMaxLength, // MetadataValueExceedsMaxLength(uint256,uint256,uint256)
	"0xe237a731": decodeMissingServiceFeeRecipient, // MissingServiceFeeRecipient()
	"0x753a1281": decodeMustSendExactNativeAmount, // MustSendExactNativeAmount(uint256,uint256)
	"0x2546923b": decodeNativeTokenNotAccepted, // NativeTokenNotAccepted(uint256)
	"0xb10b947e": decodeNativeTokenNotSupported, // NativeTokenNotSupported()
	"0xa5b05eec": decodeNativeTransferFailed, // NativeTransferFailed(address,uint256)
	"0x033bf3f1": decodeNextProvingPeriodAlreadyCalled, // NextProvingPeriodAlreadyCalled(uint256,uint256,uint256)
	"0x5d3bfcbb": decodeNoPDPPaymentRail, // NoPDPPaymentRail(uint256)
	"0xae296731": decodeNoProgressInSettlement, // NoProgressInSettlement(uint256,uint256,uint256)
	"0x766e1d31": decodeNotAuthorizedToTerminateRail, // NotAuthorizedToTerminateRail(uint256,address,address,address)
	"0x23964715": decodeOldServiceProviderMismatch, // OldServiceProviderMismatch(uint256,address,address)
	"0xc58d5cbc": decodeOneTimePaymentExceedsLockup, // OneTimePaymentExceedsLockup(uint256,uint256,uint256)
	"0xc2aebdff": decodeOnlyFilBeamControllerAllowed, // OnlyFilBeamControllerAllowed(address,address)
	"0x6459cb42": decodeOnlyPDPVerifierAllowed, // OnlyPDPVerifierAllowed(address,address)
	"0x2c0d8add": decodeOnlyRailClientAllowed, // OnlyRailClientAllowed(address,address)
	"0xf4d2d70a": decodeOnlyRailOperatorAllowed, // OnlyRailOperatorAllowed(address,address)
	"0x1dcd4c5f": decodeOnlyRailParticipantAllowed, // OnlyRailParticipantAllowed(address,address,address,address)
	"0x3ce8f537": decodeOnlySelf, // OnlySelf(address,address)
	"0x8dcd0606": decodeOperatorLockupAllowanceExceeded, // OperatorLockupAllowanceExceeded(uint256,uint256)
	"0xeef23db6": decodeOperatorNotApproved, // OperatorNotApproved(address,address)
	"0x6c577bf9": decodeOperatorRateAllowanceExceeded, // OperatorRateAllowanceExceeded(uint256,uint256)
	"0x23fe2e89": decodePaymentRailsNotFinalized, // PaymentRailsNotFinalized(uint256,uint256)
	"0x425335c3": decodeProofAlreadySubmitted, // ProofAlreadySubmitted(uint256)
	"0x431cf638": decodeProviderAlreadyApproved, // ProviderAlreadyApproved(uint256)
	"0x0d141d0c": decodeProviderNotApproved, // ProviderNotApproved(address,uint256)
	"0x52d6fdb5": decodeProviderNotInApprovedList, // ProviderNotInApprovedList(uint256)
	"0x232cb27a": decodeProviderNotRegistered, // ProviderNotRegistered(address)
	"0x28bb1a79": decodeProvingNotStarted, // ProvingNotStarted(uint256)
	"0x999010d5": decodeProvingPeriodNotInitialized, // ProvingPeriodNotInitialized(uint256)
	"0x9514f828": decodeProvingPeriodPassed, // ProvingPeriodPassed(uint256,uint256,uint256)
	"0x4947b7af": decodeRailAlreadyTerminated, // RailAlreadyTerminated(uint256)
	"0xd87df04d": decodeRailInactiveOrSettled, // RailInactiveOrSettled(uint256)
	"0x797fec96": decodeRailNotAssociated, // RailNotAssociated(uint256)
	"0x5a70954b": decodeRailNotTerminated, // RailNotTerminated(uint256)
	"0x9eb55fd7": decodeRateChangeNotAllowedOnTerminatedRail, // RateChangeNotAllowedOnTerminatedRail(uint256)
	"0xe60266a8": decodeRateChangeQueueNotEmpty, // RateChangeQueueNotEmpty(uint256)
	"0x1a1e3e28": decodeServiceContractMustTerminateRail, // ServiceContractMustTerminateRail()
	"0x5269c0dd": decodeSignerMustBeMsgSender, // SignerMustBeMsgSender(address,address)
	"0xd516067a": decodeTooManyMetadataKeys, // TooManyMetadataKeys(uint256,uint256)
	"0x425c1fae": decodeUnsupportedSignatureV, // UnsupportedSignatureV(uint8)
	"0x1fccb6c4": decodeValidatorModifiedAmountExceedsMaximum, // ValidatorModifiedAmountExceedsMaximum(uint256,uint256,uint256)
	"0x0696a4a4": decodeValidatorSettledBeforeSegmentStart, // ValidatorSettledBeforeSegmentStart(uint256,uint256,uint256)
	"0xcaa0872a": decodeValidatorSettledBeyondSegmentEnd, // ValidatorSettledBeyondSegmentEnd(uint256,uint256,uint256)
	"0xf7a5ad6d": decodeWithdrawAmountExceedsAccumulatedFees, // WithdrawAmountExceedsAccumulatedFees(address,uint256,uint256)
	"0x620b9903": decodeZeroAddress, // ZeroAddress(uint8)
	"0x44034241": decodeZeroAddressNotAllowed, // ZeroAddressNotAllowed(string)
}


// decodeCDNPaymentAlreadyTerminated decodes CDNPaymentAlreadyTerminated error parameters
func decodeCDNPaymentAlreadyTerminated(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &CDNPaymentAlreadyTerminated{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeCacheMissPaymentAlreadyTerminated decodes CacheMissPaymentAlreadyTerminated error parameters
func decodeCacheMissPaymentAlreadyTerminated(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &CacheMissPaymentAlreadyTerminated{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeCallerNotPayer decodes CallerNotPayer error parameters
func decodeCallerNotPayer(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &CallerNotPayer{
		DataSetId: values[0].(*big.Int),
		ExpectedPayer: values[1].(common.Address),
		Caller: values[2].(common.Address),
	}, nil
}


// decodeCallerNotPayerOrPayee decodes CallerNotPayerOrPayee error parameters
func decodeCallerNotPayerOrPayee(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &CallerNotPayerOrPayee{
		DataSetId: values[0].(*big.Int),
		ExpectedPayer: values[1].(common.Address),
		ExpectedPayee: values[2].(common.Address),
		Caller: values[3].(common.Address),
	}, nil
}


// decodeCallerNotPayments decodes CallerNotPayments error parameters
func decodeCallerNotPayments(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &CallerNotPayments{
		Expected: values[0].(common.Address),
		Actual: values[1].(common.Address),
	}, nil
}


// decodeCannotModifyTerminatedRailBeyondEndEpoch decodes CannotModifyTerminatedRailBeyondEndEpoch error parameters
func decodeCannotModifyTerminatedRailBeyondEndEpoch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &CannotModifyTerminatedRailBeyondEndEpoch{
		RailId: values[0].(*big.Int),
		MaxSettlementEpoch: values[1].(*big.Int),
		BlockNumber: values[2].(*big.Int),
	}, nil
}


// decodeCannotSettleFutureEpochs decodes CannotSettleFutureEpochs error parameters
func decodeCannotSettleFutureEpochs(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &CannotSettleFutureEpochs{
		RailId: values[0].(*big.Int),
		MaxAllowedEpoch: values[1].(*big.Int),
		AttemptedEpoch: values[2].(*big.Int),
	}, nil
}


// decodeCannotSettleTerminatedRailBeforeMaxEpoch decodes CannotSettleTerminatedRailBeforeMaxEpoch error parameters
func decodeCannotSettleTerminatedRailBeforeMaxEpoch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &CannotSettleTerminatedRailBeforeMaxEpoch{
		RailId: values[0].(*big.Int),
		RequiredBlock: values[1].(*big.Int),
		CurrentBlock: values[2].(*big.Int),
	}, nil
}


// decodeChallengeWindowTooEarly decodes ChallengeWindowTooEarly error parameters
func decodeChallengeWindowTooEarly(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &ChallengeWindowTooEarly{
		DataSetId: values[0].(*big.Int),
		WindowStart: values[1].(*big.Int),
		NowBlock: values[2].(*big.Int),
	}, nil
}


// decodeCommissionExceedsMaximum decodes CommissionExceedsMaximum error parameters
func decodeCommissionExceedsMaximum(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint8")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &CommissionExceedsMaximum{
		CommissionType: uint8(values[0].(uint8)),
		Max: values[1].(*big.Int),
		Actual: values[2].(*big.Int),
	}, nil
}


// decodeCommissionRateTooHigh decodes CommissionRateTooHigh error parameters
func decodeCommissionRateTooHigh(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &CommissionRateTooHigh{
		MaxAllowed: values[0].(*big.Int),
		Actual: values[1].(*big.Int),
	}, nil
}


// decodeCurrentLockupLessThanOldLockup decodes CurrentLockupLessThanOldLockup error parameters
func decodeCurrentLockupLessThanOldLockup(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &CurrentLockupLessThanOldLockup{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		OldLockup: values[2].(*big.Int),
		CurrentLockup: values[3].(*big.Int),
	}, nil
}


// decodeDataSetNotFoundForRail decodes DataSetNotFoundForRail error parameters
func decodeDataSetNotFoundForRail(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &DataSetNotFoundForRail{
		RailId: values[0].(*big.Int),
	}, nil
}


// decodeDataSetNotRegistered decodes DataSetNotRegistered error parameters
func decodeDataSetNotRegistered(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &DataSetNotRegistered{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeDataSetPaymentAlreadyTerminated decodes DataSetPaymentAlreadyTerminated error parameters
func decodeDataSetPaymentAlreadyTerminated(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &DataSetPaymentAlreadyTerminated{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeDataSetPaymentBeyondEndEpoch decodes DataSetPaymentBeyondEndEpoch error parameters
func decodeDataSetPaymentBeyondEndEpoch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &DataSetPaymentBeyondEndEpoch{
		DataSetId: values[0].(*big.Int),
		PdpEndEpoch: values[1].(*big.Int),
		CurrentBlock: values[2].(*big.Int),
	}, nil
}


// decodeDivisionByZero decodes DivisionByZero error parameters
func decodeDivisionByZero(data []byte) (ContractError, error) {
	return &DivisionByZero{}, nil
}


// decodeDuplicateMetadataKey decodes DuplicateMetadataKey error parameters
func decodeDuplicateMetadataKey(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("string")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &DuplicateMetadataKey{
		DataSetId: values[0].(*big.Int),
		Key: values[1].(string),
	}, nil
}


// decodeExtraDataRequired decodes ExtraDataRequired error parameters
func decodeExtraDataRequired(data []byte) (ContractError, error) {
	return &ExtraDataRequired{}, nil
}


// decodeFeeWithdrawalNativeTransferFailed decodes FeeWithdrawalNativeTransferFailed error parameters
func decodeFeeWithdrawalNativeTransferFailed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &FeeWithdrawalNativeTransferFailed{
		To: values[0].(common.Address),
		Amount: values[1].(*big.Int),
	}, nil
}


// decodeFilBeamServiceNotConfigured decodes FilBeamServiceNotConfigured error parameters
func decodeFilBeamServiceNotConfigured(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &FilBeamServiceNotConfigured{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeInsufficientCurrentLockup decodes InsufficientCurrentLockup error parameters
func decodeInsufficientCurrentLockup(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &InsufficientCurrentLockup{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		CurrentLockup: values[2].(*big.Int),
		LockupReduction: values[3].(*big.Int),
	}, nil
}


// decodeInsufficientFundsForOneTimePayment decodes InsufficientFundsForOneTimePayment error parameters
func decodeInsufficientFundsForOneTimePayment(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &InsufficientFundsForOneTimePayment{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		Required: values[2].(*big.Int),
		Actual: values[3].(*big.Int),
	}, nil
}


// decodeInsufficientFundsForSettlement decodes InsufficientFundsForSettlement error parameters
func decodeInsufficientFundsForSettlement(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &InsufficientFundsForSettlement{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		Available: values[2].(*big.Int),
		Required: values[3].(*big.Int),
	}, nil
}


// decodeInsufficientLockupForSettlement decodes InsufficientLockupForSettlement error parameters
func decodeInsufficientLockupForSettlement(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &InsufficientLockupForSettlement{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		Available: values[2].(*big.Int),
		Required: values[3].(*big.Int),
	}, nil
}


// decodeInsufficientNativeTokenForBurn decodes InsufficientNativeTokenForBurn error parameters
func decodeInsufficientNativeTokenForBurn(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InsufficientNativeTokenForBurn{
		Required: values[0].(*big.Int),
		Sent: values[1].(*big.Int),
	}, nil
}


// decodeInsufficientUnlockedFunds decodes InsufficientUnlockedFunds error parameters
func decodeInsufficientUnlockedFunds(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InsufficientUnlockedFunds{
		Available: values[0].(*big.Int),
		Requested: values[1].(*big.Int),
	}, nil
}


// decodeInvalidChallengeCount decodes InvalidChallengeCount error parameters
func decodeInvalidChallengeCount(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &InvalidChallengeCount{
		DataSetId: values[0].(*big.Int),
		MinExpected: values[1].(*big.Int),
		Actual: values[2].(*big.Int),
	}, nil
}


// decodeInvalidChallengeEpoch decodes InvalidChallengeEpoch error parameters
func decodeInvalidChallengeEpoch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &InvalidChallengeEpoch{
		DataSetId: values[0].(*big.Int),
		MinAllowed: values[1].(*big.Int),
		MaxAllowed: values[2].(*big.Int),
		Actual: values[3].(*big.Int),
	}, nil
}


// decodeInvalidChallengeWindowSize decodes InvalidChallengeWindowSize error parameters
func decodeInvalidChallengeWindowSize(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InvalidChallengeWindowSize{
		MaxProvingPeriod: values[0].(*big.Int),
		ChallengeWindowSize: values[1].(*big.Int),
	}, nil
}


// decodeInvalidDataSetId decodes InvalidDataSetId error parameters
func decodeInvalidDataSetId(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &InvalidDataSetId{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeInvalidEpochRange decodes InvalidEpochRange error parameters
func decodeInvalidEpochRange(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InvalidEpochRange{
		FromEpoch: values[0].(*big.Int),
		ToEpoch: values[1].(*big.Int),
	}, nil
}


// decodeInvalidRateChangeQueueState decodes InvalidRateChangeQueueState error parameters
func decodeInvalidRateChangeQueueState(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InvalidRateChangeQueueState{
		NextRateChangeUntilEpoch: values[0].(*big.Int),
		ProcessedEpoch: values[1].(*big.Int),
	}, nil
}


// decodeInvalidSignature decodes InvalidSignature error parameters
func decodeInvalidSignature(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InvalidSignature{
		Expected: values[0].(common.Address),
		Actual: values[1].(common.Address),
	}, nil
}


// decodeInvalidSignatureLength decodes InvalidSignatureLength error parameters
func decodeInvalidSignatureLength(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &InvalidSignatureLength{
		ExpectedLength: values[0].(*big.Int),
		ActualLength: values[1].(*big.Int),
	}, nil
}


// decodeInvalidTerminatedRailModification decodes InvalidTerminatedRailModification error parameters
func decodeInvalidTerminatedRailModification(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &InvalidTerminatedRailModification{
		ActualPeriod: values[0].(*big.Int),
		ActualLockupFixed: values[1].(*big.Int),
		AttemptedPeriod: values[2].(*big.Int),
		AttemptedLockupFixed: values[3].(*big.Int),
	}, nil
}


// decodeInvalidTopUpAmount decodes InvalidTopUpAmount error parameters
func decodeInvalidTopUpAmount(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &InvalidTopUpAmount{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeLockupExceedsFundsInvariant decodes LockupExceedsFundsInvariant error parameters
func decodeLockupExceedsFundsInvariant(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &LockupExceedsFundsInvariant{
		Token: values[0].(common.Address),
		Account: values[1].(common.Address),
		LockupCurrent: values[2].(*big.Int),
		FundsCurrent: values[3].(*big.Int),
	}, nil
}


// decodeLockupFixedIncreaseNotAllowedDueToInsufficientFunds decodes LockupFixedIncreaseNotAllowedDueToInsufficientFunds error parameters
func decodeLockupFixedIncreaseNotAllowedDueToInsufficientFunds(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &LockupFixedIncreaseNotAllowedDueToInsufficientFunds{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		ActualLockupFixed: values[2].(*big.Int),
		AttemptedLockupFixed: values[3].(*big.Int),
	}, nil
}


// decodeLockupInconsistencyDuringRailFinalization decodes LockupInconsistencyDuringRailFinalization error parameters
func decodeLockupInconsistencyDuringRailFinalization(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 5 {
		return nil, fmt.Errorf("expected 5 values, got %d", len(values))
	}

	return &LockupInconsistencyDuringRailFinalization{
		RailId: values[0].(*big.Int),
		Token: values[1].(common.Address),
		From: values[2].(common.Address),
		ExpectedLockup: values[3].(*big.Int),
		ActualLockup: values[4].(*big.Int),
	}, nil
}


// decodeLockupNotSettledRateChangeNotAllowed decodes LockupNotSettledRateChangeNotAllowed error parameters
func decodeLockupNotSettledRateChangeNotAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("bool")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 5 {
		return nil, fmt.Errorf("expected 5 values, got %d", len(values))
	}

	return &LockupNotSettledRateChangeNotAllowed{
		RailId: values[0].(*big.Int),
		From: values[1].(common.Address),
		IsSettled: values[2].(bool),
		CurrentRate: values[3].(*big.Int),
		AttemptedRate: values[4].(*big.Int),
	}, nil
}


// decodeLockupPeriodChangeNotAllowedDueToInsufficientFunds decodes LockupPeriodChangeNotAllowedDueToInsufficientFunds error parameters
func decodeLockupPeriodChangeNotAllowedDueToInsufficientFunds(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &LockupPeriodChangeNotAllowedDueToInsufficientFunds{
		Token: values[0].(common.Address),
		From: values[1].(common.Address),
		ActualLockupPeriod: values[2].(*big.Int),
		AttemptedLockupPeriod: values[3].(*big.Int),
	}, nil
}


// decodeLockupPeriodExceedsOperatorMaximum decodes LockupPeriodExceedsOperatorMaximum error parameters
func decodeLockupPeriodExceedsOperatorMaximum(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &LockupPeriodExceedsOperatorMaximum{
		Token: values[0].(common.Address),
		Operator: values[1].(common.Address),
		MaxAllowedPeriod: values[2].(*big.Int),
		RequestedPeriod: values[3].(*big.Int),
	}, nil
}


// decodeLockupRateInconsistent decodes LockupRateInconsistent error parameters
func decodeLockupRateInconsistent(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &LockupRateInconsistent{
		RailId: values[0].(*big.Int),
		From: values[1].(common.Address),
		PaymentRate: values[2].(*big.Int),
		LockupRate: values[3].(*big.Int),
	}, nil
}


// decodeLockupRateLessThanOldRate decodes LockupRateLessThanOldRate error parameters
func decodeLockupRateLessThanOldRate(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &LockupRateLessThanOldRate{
		RailId: values[0].(*big.Int),
		From: values[1].(common.Address),
		LockupRate: values[2].(*big.Int),
		OldRate: values[3].(*big.Int),
	}, nil
}


// decodeMaxProvingPeriodZero decodes MaxProvingPeriodZero error parameters
func decodeMaxProvingPeriodZero(data []byte) (ContractError, error) {
	return &MaxProvingPeriodZero{}, nil
}


// decodeMetadataArrayCountMismatch decodes MetadataArrayCountMismatch error parameters
func decodeMetadataArrayCountMismatch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &MetadataArrayCountMismatch{
		MetadataArrayCount: values[0].(*big.Int),
		PieceCount: values[1].(*big.Int),
	}, nil
}


// decodeMetadataKeyAndValueLengthMismatch decodes MetadataKeyAndValueLengthMismatch error parameters
func decodeMetadataKeyAndValueLengthMismatch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &MetadataKeyAndValueLengthMismatch{
		KeysLength: values[0].(*big.Int),
		ValuesLength: values[1].(*big.Int),
	}, nil
}


// decodeMetadataKeyExceedsMaxLength decodes MetadataKeyExceedsMaxLength error parameters
func decodeMetadataKeyExceedsMaxLength(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &MetadataKeyExceedsMaxLength{
		Index: values[0].(*big.Int),
		MaxAllowed: values[1].(*big.Int),
		Length: values[2].(*big.Int),
	}, nil
}


// decodeMetadataValueExceedsMaxLength decodes MetadataValueExceedsMaxLength error parameters
func decodeMetadataValueExceedsMaxLength(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &MetadataValueExceedsMaxLength{
		Index: values[0].(*big.Int),
		MaxAllowed: values[1].(*big.Int),
		Length: values[2].(*big.Int),
	}, nil
}


// decodeMissingServiceFeeRecipient decodes MissingServiceFeeRecipient error parameters
func decodeMissingServiceFeeRecipient(data []byte) (ContractError, error) {
	return &MissingServiceFeeRecipient{}, nil
}


// decodeMustSendExactNativeAmount decodes MustSendExactNativeAmount error parameters
func decodeMustSendExactNativeAmount(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &MustSendExactNativeAmount{
		Required: values[0].(*big.Int),
		Sent: values[1].(*big.Int),
	}, nil
}


// decodeNativeTokenNotAccepted decodes NativeTokenNotAccepted error parameters
func decodeNativeTokenNotAccepted(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &NativeTokenNotAccepted{
		Sent: values[0].(*big.Int),
	}, nil
}


// decodeNativeTokenNotSupported decodes NativeTokenNotSupported error parameters
func decodeNativeTokenNotSupported(data []byte) (ContractError, error) {
	return &NativeTokenNotSupported{}, nil
}


// decodeNativeTransferFailed decodes NativeTransferFailed error parameters
func decodeNativeTransferFailed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &NativeTransferFailed{
		To: values[0].(common.Address),
		Amount: values[1].(*big.Int),
	}, nil
}


// decodeNextProvingPeriodAlreadyCalled decodes NextProvingPeriodAlreadyCalled error parameters
func decodeNextProvingPeriodAlreadyCalled(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &NextProvingPeriodAlreadyCalled{
		DataSetId: values[0].(*big.Int),
		PeriodDeadline: values[1].(*big.Int),
		NowBlock: values[2].(*big.Int),
	}, nil
}


// decodeNoPDPPaymentRail decodes NoPDPPaymentRail error parameters
func decodeNoPDPPaymentRail(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &NoPDPPaymentRail{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeNoProgressInSettlement decodes NoProgressInSettlement error parameters
func decodeNoProgressInSettlement(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &NoProgressInSettlement{
		RailId: values[0].(*big.Int),
		ExpectedSettledUpTo: values[1].(*big.Int),
		ActualSettledUpTo: values[2].(*big.Int),
	}, nil
}


// decodeNotAuthorizedToTerminateRail decodes NotAuthorizedToTerminateRail error parameters
func decodeNotAuthorizedToTerminateRail(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &NotAuthorizedToTerminateRail{
		RailId: values[0].(*big.Int),
		AllowedClient: values[1].(common.Address),
		AllowedOperator: values[2].(common.Address),
		Caller: values[3].(common.Address),
	}, nil
}


// decodeOldServiceProviderMismatch decodes OldServiceProviderMismatch error parameters
func decodeOldServiceProviderMismatch(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &OldServiceProviderMismatch{
		DataSetId: values[0].(*big.Int),
		Expected: values[1].(common.Address),
		Actual: values[2].(common.Address),
	}, nil
}


// decodeOneTimePaymentExceedsLockup decodes OneTimePaymentExceedsLockup error parameters
func decodeOneTimePaymentExceedsLockup(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &OneTimePaymentExceedsLockup{
		RailId: values[0].(*big.Int),
		Available: values[1].(*big.Int),
		Required: values[2].(*big.Int),
	}, nil
}


// decodeOnlyFilBeamControllerAllowed decodes OnlyFilBeamControllerAllowed error parameters
func decodeOnlyFilBeamControllerAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OnlyFilBeamControllerAllowed{
		Expected: values[0].(common.Address),
		Actual: values[1].(common.Address),
	}, nil
}


// decodeOnlyPDPVerifierAllowed decodes OnlyPDPVerifierAllowed error parameters
func decodeOnlyPDPVerifierAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OnlyPDPVerifierAllowed{
		Expected: values[0].(common.Address),
		Actual: values[1].(common.Address),
	}, nil
}


// decodeOnlyRailClientAllowed decodes OnlyRailClientAllowed error parameters
func decodeOnlyRailClientAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OnlyRailClientAllowed{
		Expected: values[0].(common.Address),
		Caller: values[1].(common.Address),
	}, nil
}


// decodeOnlyRailOperatorAllowed decodes OnlyRailOperatorAllowed error parameters
func decodeOnlyRailOperatorAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OnlyRailOperatorAllowed{
		Expected: values[0].(common.Address),
		Caller: values[1].(common.Address),
	}, nil
}


// decodeOnlyRailParticipantAllowed decodes OnlyRailParticipantAllowed error parameters
func decodeOnlyRailParticipantAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 4 {
		return nil, fmt.Errorf("expected 4 values, got %d", len(values))
	}

	return &OnlyRailParticipantAllowed{
		ExpectedFrom: values[0].(common.Address),
		ExpectedOperator: values[1].(common.Address),
		ExpectedTo: values[2].(common.Address),
		Caller: values[3].(common.Address),
	}, nil
}


// decodeOnlySelf decodes OnlySelf error parameters
func decodeOnlySelf(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OnlySelf{
		Expected: values[0].(common.Address),
		Actual: values[1].(common.Address),
	}, nil
}


// decodeOperatorLockupAllowanceExceeded decodes OperatorLockupAllowanceExceeded error parameters
func decodeOperatorLockupAllowanceExceeded(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OperatorLockupAllowanceExceeded{
		Allowed: values[0].(*big.Int),
		AttemptedUsage: values[1].(*big.Int),
	}, nil
}


// decodeOperatorNotApproved decodes OperatorNotApproved error parameters
func decodeOperatorNotApproved(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OperatorNotApproved{
		From: values[0].(common.Address),
		Operator: values[1].(common.Address),
	}, nil
}


// decodeOperatorRateAllowanceExceeded decodes OperatorRateAllowanceExceeded error parameters
func decodeOperatorRateAllowanceExceeded(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &OperatorRateAllowanceExceeded{
		Allowed: values[0].(*big.Int),
		AttemptedUsage: values[1].(*big.Int),
	}, nil
}


// decodePaymentRailsNotFinalized decodes PaymentRailsNotFinalized error parameters
func decodePaymentRailsNotFinalized(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &PaymentRailsNotFinalized{
		DataSetId: values[0].(*big.Int),
		PdpEndEpoch: values[1].(*big.Int),
	}, nil
}


// decodeProofAlreadySubmitted decodes ProofAlreadySubmitted error parameters
func decodeProofAlreadySubmitted(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ProofAlreadySubmitted{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeProviderAlreadyApproved decodes ProviderAlreadyApproved error parameters
func decodeProviderAlreadyApproved(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ProviderAlreadyApproved{
		ProviderId: values[0].(*big.Int),
	}, nil
}


// decodeProviderNotApproved decodes ProviderNotApproved error parameters
func decodeProviderNotApproved(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &ProviderNotApproved{
		Provider: values[0].(common.Address),
		ProviderId: values[1].(*big.Int),
	}, nil
}


// decodeProviderNotInApprovedList decodes ProviderNotInApprovedList error parameters
func decodeProviderNotInApprovedList(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ProviderNotInApprovedList{
		ProviderId: values[0].(*big.Int),
	}, nil
}


// decodeProviderNotRegistered decodes ProviderNotRegistered error parameters
func decodeProviderNotRegistered(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ProviderNotRegistered{
		Provider: values[0].(common.Address),
	}, nil
}


// decodeProvingNotStarted decodes ProvingNotStarted error parameters
func decodeProvingNotStarted(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ProvingNotStarted{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeProvingPeriodNotInitialized decodes ProvingPeriodNotInitialized error parameters
func decodeProvingPeriodNotInitialized(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ProvingPeriodNotInitialized{
		DataSetId: values[0].(*big.Int),
	}, nil
}


// decodeProvingPeriodPassed decodes ProvingPeriodPassed error parameters
func decodeProvingPeriodPassed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &ProvingPeriodPassed{
		DataSetId: values[0].(*big.Int),
		Deadline: values[1].(*big.Int),
		NowBlock: values[2].(*big.Int),
	}, nil
}


// decodeRailAlreadyTerminated decodes RailAlreadyTerminated error parameters
func decodeRailAlreadyTerminated(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &RailAlreadyTerminated{
		RailId: values[0].(*big.Int),
	}, nil
}


// decodeRailInactiveOrSettled decodes RailInactiveOrSettled error parameters
func decodeRailInactiveOrSettled(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &RailInactiveOrSettled{
		RailId: values[0].(*big.Int),
	}, nil
}


// decodeRailNotAssociated decodes RailNotAssociated error parameters
func decodeRailNotAssociated(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &RailNotAssociated{
		RailId: values[0].(*big.Int),
	}, nil
}


// decodeRailNotTerminated decodes RailNotTerminated error parameters
func decodeRailNotTerminated(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &RailNotTerminated{
		RailId: values[0].(*big.Int),
	}, nil
}


// decodeRateChangeNotAllowedOnTerminatedRail decodes RateChangeNotAllowedOnTerminatedRail error parameters
func decodeRateChangeNotAllowedOnTerminatedRail(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &RateChangeNotAllowedOnTerminatedRail{
		RailId: values[0].(*big.Int),
	}, nil
}


// decodeRateChangeQueueNotEmpty decodes RateChangeQueueNotEmpty error parameters
func decodeRateChangeQueueNotEmpty(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &RateChangeQueueNotEmpty{
		NextUntilEpoch: values[0].(*big.Int),
	}, nil
}


// decodeServiceContractMustTerminateRail decodes ServiceContractMustTerminateRail error parameters
func decodeServiceContractMustTerminateRail(data []byte) (ContractError, error) {
	return &ServiceContractMustTerminateRail{}, nil
}


// decodeSignerMustBeMsgSender decodes SignerMustBeMsgSender error parameters
func decodeSignerMustBeMsgSender(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("address")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &SignerMustBeMsgSender{
		Expected: values[0].(common.Address),
		Actual: values[1].(common.Address),
	}, nil
}


// decodeTooManyMetadataKeys decodes TooManyMetadataKeys error parameters
func decodeTooManyMetadataKeys(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 2 {
		return nil, fmt.Errorf("expected 2 values, got %d", len(values))
	}

	return &TooManyMetadataKeys{
		MaxAllowed: values[0].(*big.Int),
		KeysLength: values[1].(*big.Int),
	}, nil
}


// decodeUnsupportedSignatureV decodes UnsupportedSignatureV error parameters
func decodeUnsupportedSignatureV(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint8")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &UnsupportedSignatureV{
		V: uint8(values[0].(uint8)),
	}, nil
}


// decodeValidatorModifiedAmountExceedsMaximum decodes ValidatorModifiedAmountExceedsMaximum error parameters
func decodeValidatorModifiedAmountExceedsMaximum(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &ValidatorModifiedAmountExceedsMaximum{
		RailId: values[0].(*big.Int),
		MaxAllowed: values[1].(*big.Int),
		Attempted: values[2].(*big.Int),
	}, nil
}


// decodeValidatorSettledBeforeSegmentStart decodes ValidatorSettledBeforeSegmentStart error parameters
func decodeValidatorSettledBeforeSegmentStart(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &ValidatorSettledBeforeSegmentStart{
		RailId: values[0].(*big.Int),
		AllowedStart: values[1].(*big.Int),
		AttemptedStart: values[2].(*big.Int),
	}, nil
}


// decodeValidatorSettledBeyondSegmentEnd decodes ValidatorSettledBeyondSegmentEnd error parameters
func decodeValidatorSettledBeyondSegmentEnd(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &ValidatorSettledBeyondSegmentEnd{
		RailId: values[0].(*big.Int),
		AllowedEnd: values[1].(*big.Int),
		AttemptedEnd: values[2].(*big.Int),
	}, nil
}


// decodeWithdrawAmountExceedsAccumulatedFees decodes WithdrawAmountExceedsAccumulatedFees error parameters
func decodeWithdrawAmountExceedsAccumulatedFees(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("address")},
		{Type: mustNewType("uint256")},
		{Type: mustNewType("uint256")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 3 {
		return nil, fmt.Errorf("expected 3 values, got %d", len(values))
	}

	return &WithdrawAmountExceedsAccumulatedFees{
		Token: values[0].(common.Address),
		Available: values[1].(*big.Int),
		Requested: values[2].(*big.Int),
	}, nil
}


// decodeZeroAddress decodes ZeroAddress error parameters
func decodeZeroAddress(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("uint8")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ZeroAddress{
		Field: uint8(values[0].(uint8)),
	}, nil
}


// decodeZeroAddressNotAllowed decodes ZeroAddressNotAllowed error parameters
func decodeZeroAddressNotAllowed(data []byte) (ContractError, error) {
	// Define ABI arguments
	arguments := abi.Arguments{
		{Type: mustNewType("string")},
	}

	// Unpack the data
	values, err := arguments.Unpack(data)
	if err != nil {
		return nil, fmt.Errorf("failed to unpack error data: %w", err)
	}

	if len(values) != 1 {
		return nil, fmt.Errorf("expected 1 values, got %d", len(values))
	}

	return &ZeroAddressNotAllowed{
		VarName: values[0].(string),
	}, nil
}



// mustNewType creates a new ABI type, panicking on error
func mustNewType(t string) abi.Type {
	typ, err := abi.NewType(t, "", nil)
	if err != nil {
		panic(fmt.Sprintf("failed to create ABI type %s: %v", t, err))
	}
	return typ
}
